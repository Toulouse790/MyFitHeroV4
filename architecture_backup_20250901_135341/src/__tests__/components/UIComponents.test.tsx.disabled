/**
 * Tests pour les composants UI de base
 * Tests des composants Button, Input, Modal, etc.
 */

import React from 'react';
import { screen } from '@testing-library/react';
import { render, userEvent } from '../../test-utils/test-utils';
import { Button } from '../../components/ui/button';
import { Input } from '../../components/ui/input';
import { Badge } from '../../components/ui/badge';

describe('Composants UI de base', () => {
  describe('Button', () => {
    it('rend un bouton basique', () => {
      render(<Button>Click me</Button>);

      const button = screen.getByRole('button', { name: 'Click me' });
      expect(button).toBeInTheDocument();
      expect(button).toHaveTextContent('Click me');
    });

    it('applique les variantes de style', () => {
      const { rerender } = render(<Button variant="default">Default</Button>);

      const button = screen.getByRole('button');
      expect(button).toHaveClass(/bg-primary/); // ou la classe appropriée

      rerender(<Button variant="destructive">Destructive</Button>);
      expect(button).toHaveClass(/bg-destructive/);

      rerender(<Button variant="outline">Outline</Button>);
      expect(button).toHaveClass(/border/);

      rerender(<Button variant="secondary">Secondary</Button>);
      expect(button).toHaveClass(/bg-secondary/);

      rerender(<Button variant="ghost">Ghost</Button>);
      expect(button).toHaveClass(/hover:bg-accent/);

      rerender(<Button variant="link">Link</Button>);
      expect(button).toHaveClass(/underline-offset-4/);
    });

    it('applique les tailles', () => {
      const { rerender } = render(<Button size="default">Default</Button>);

      const button = screen.getByRole('button');
      expect(button).toBeInTheDocument();

      rerender(<Button size="sm">Small</Button>);
      expect(button).toHaveClass(/px-3/);

      rerender(<Button size="lg">Large</Button>);
      expect(button).toHaveClass(/px-8/);

      rerender(<Button size="icon">Icon</Button>);
      expect(button).toHaveClass(/h-10/);
    });

    it("gère l'état disabled", () => {
      render(<Button disabled>Disabled</Button>);

      const button = screen.getByRole('button');
      expect(button).toBeDisabled();
      expect(button).toHaveClass(/disabled:pointer-events-none/);
    });

    it('gère les événements de clic', async () => {
      const user = userEvent.setup();
      const handleClick = jest.fn();

      render(<Button onClick={handleClick}>Click me</Button>);

      const button = screen.getByRole('button');
      await user.click(button);

      expect(handleClick).toHaveBeenCalledTimes(1);
    });

    it("ne déclenche pas d'événement quand disabled", async () => {
      const user = userEvent.setup();
      const handleClick = jest.fn();

      render(
        <Button disabled onClick={handleClick}>
          Disabled
        </Button>
      );

      const button = screen.getByRole('button');
      await user.click(button);

      expect(handleClick).not.toHaveBeenCalled();
    });

    it('supporte les refs', () => {
      const ref = React.createRef<HTMLButtonElement>();

      render(<Button ref={ref}>Button</Button>);

      expect(ref.current).toBeInstanceOf(HTMLButtonElement);
    });

    it('rend comme un autre élément avec asChild', () => {
      render(
        <Button asChild>
          <a href="/test">Link Button</a>
        </Button>
      );

      const link = screen.getByRole('link');
      expect(link).toBeInTheDocument();
      expect(link).toHaveAttribute('href', '/test');
    });
  });

  describe('Input', () => {
    it('rend un input basique', () => {
      render(<Input placeholder="Enter text" />);

      const input = screen.getByPlaceholderText('Enter text');
      expect(input).toBeInTheDocument();
      // Les inputs HTML n'ont pas forcément l'attribut type="text" par défaut
      expect(input).toBeInstanceOf(HTMLInputElement);
    });

    it("gère différents types d'input", () => {
      const { rerender } = render(<Input type="email" />);

      let input = screen.getByRole('textbox');
      expect(input).toHaveAttribute('type', 'email');

      rerender(<Input type="password" />);
      // Pour password, on ne peut pas utiliser getByRole car c'est masqué
      input = document.querySelector('input[type="password"]') as HTMLInputElement;
      expect(input).toHaveAttribute('type', 'password');

      rerender(<Input type="number" />);
      input = screen.getByRole('spinbutton');
      expect(input).toHaveAttribute('type', 'number');
    });

    it('gère la valeur et les changements', async () => {
      const user = userEvent.setup();
      const handleChange = jest.fn();

      render(<Input value="initial" onChange={handleChange} />);

      const input = screen.getByDisplayValue('initial');
      expect(input).toHaveValue('initial');

      await user.clear(input);
      await user.type(input, 'new value');

      expect(handleChange).toHaveBeenCalled();
    });

    it("gère l'état disabled", () => {
      render(<Input disabled placeholder="Disabled input" />);

      const input = screen.getByPlaceholderText('Disabled input');
      expect(input).toBeDisabled();
    });

    it('applique les classes CSS personnalisées', () => {
      render(<Input className="custom-class" />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveClass('custom-class');
    });

    it('supporte les attributs HTML standard', () => {
      render(<Input id="test-input" name="testName" required maxLength={10} minLength={2} />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveAttribute('id', 'test-input');
      expect(input).toHaveAttribute('name', 'testName');
      expect(input).toHaveAttribute('required');
      expect(input).toHaveAttribute('maxlength', '10');
      expect(input).toHaveAttribute('minlength', '2');
    });

    it('supporte les refs', () => {
      const ref = React.createRef<HTMLInputElement>();

      render(<Input ref={ref} />);

      expect(ref.current).toBeInstanceOf(HTMLInputElement);
    });
  });

  describe('Badge', () => {
    it('rend un badge basique', () => {
      render(<Badge>Default Badge</Badge>);

      expect(screen.getByText('Default Badge')).toBeInTheDocument();
    });

    it('applique les variantes de style', () => {
      const { rerender } = render(<Badge variant="default">Default</Badge>);

      let badge = screen.getByText('Default');
      expect(badge).toHaveClass(/bg-primary/);

      rerender(<Badge variant="secondary">Secondary</Badge>);
      badge = screen.getByText('Secondary');
      expect(badge).toHaveClass(/bg-secondary/);

      rerender(<Badge variant="destructive">Destructive</Badge>);
      badge = screen.getByText('Destructive');
      expect(badge).toHaveClass(/bg-destructive/);

      rerender(<Badge variant="outline">Outline</Badge>);
      badge = screen.getByText('Outline');
      expect(badge).toHaveClass(/border/);
    });

    it('applique les classes CSS personnalisées', () => {
      render(<Badge className="custom-badge">Custom</Badge>);

      const badge = screen.getByText('Custom');
      expect(badge).toHaveClass('custom-badge');
    });

    it('rend comme un autre élément avec asChild', () => {
      render(
        <Badge asChild>
          <a href="/badge">Badge Link</a>
        </Badge>
      );

      const link = screen.getByRole('link');
      expect(link).toBeInTheDocument();
      expect(link).toHaveAttribute('href', '/badge');
    });
  });

  describe('Intégration entre composants', () => {
    it('combine Button et Badge', () => {
      render(
        <Button>
          Action <Badge variant="secondary">New</Badge>
        </Button>
      );

      const button = screen.getByRole('button');
      expect(button).toHaveTextContent('Action New');
      expect(screen.getByText('New')).toBeInTheDocument();
    });

    it('utilise Input dans un formulaire', async () => {
      const user = userEvent.setup();
      const handleSubmit = jest.fn(e => e.preventDefault());

      render(
        <form onSubmit={handleSubmit}>
          <Input name="username" placeholder="Username" required />
          <Button type="submit">Submit</Button>
        </form>
      );

      const input = screen.getByPlaceholderText('Username');
      const button = screen.getByRole('button', { name: 'Submit' });

      await user.type(input, 'testuser');
      await user.click(button);

      expect(handleSubmit).toHaveBeenCalled();
    });
  });

  describe('Thèmes et styles', () => {
    it('respecte le thème sombre', () => {
      render(
        <div className="dark">
          <Button>Dark Button</Button>
        </div>
      );

      const button = screen.getByRole('button');
      // Vérifier que les classes de thème sombre sont appliquées
      expect(button.closest('.dark')).toBeInTheDocument();
    });

    it('applique les animations CSS', async () => {
      const user = userEvent.setup();

      render(<Button>Animated Button</Button>);

      const button = screen.getByRole('button');

      // Simuler le hover pour tester les animations
      await user.hover(button);

      // Vérifier que les classes d'animation sont présentes
      expect(button).toHaveClass(/transition/);
    });
  });

  describe('Accessibilité', () => {
    it('supporte les labels appropriés', () => {
      render(
        <div>
          <label htmlFor="test-input">Test Label</label>
          <Input id="test-input" />
        </div>
      );

      const input = screen.getByLabelText('Test Label');
      expect(input).toBeInTheDocument();
    });

    it('supporte aria-describedby', () => {
      render(
        <div>
          <Input aria-describedby="help-text" />
          <div id="help-text">Help text</div>
        </div>
      );

      const input = screen.getByRole('textbox');
      expect(input).toHaveAttribute('aria-describedby', 'help-text');
    });

    it('indique les erreurs de validation', () => {
      render(<Input aria-invalid="true" aria-describedby="error-message" />);

      const input = screen.getByRole('textbox');
      expect(input).toHaveAttribute('aria-invalid', 'true');
    });

    it('supporte les raccourcis clavier', async () => {
      const user = userEvent.setup();
      const handleClick = jest.fn();

      render(<Button onClick={handleClick}>Space to click</Button>);

      const button = screen.getByRole('button');
      button.focus();

      await user.keyboard(' ');
      expect(handleClick).toHaveBeenCalled();

      await user.keyboard('{Enter}');
      expect(handleClick).toHaveBeenCalledTimes(2);
    });
  });
});
